ООП в сооздании ПО:

Классы, создание классов, их проработка используется чаще всего в начале написания программы, в процессе создания общей структуры
обоснования использования:
- (*Абстрация)используется для создание новго типа объектов, которое интуинтивно упрощает работу с программными объектами проецируя их на объекты реальности (dog.bark() - команда собаке гафкать)
- так-же создаёт шаблон для объектов, сохраняя среди них порядок (не нужно следить за тем, как что-бы за каждым объектом были прописанны отдельные переменные или массивы, ведь проще их каждому задать в обязательном порядке)
- встроенные методы и свойтсва повышают удобство работы с конкретным объектом, особенно если они имеют ограничения по доступу (num_array.sum() - использование встроенной функции суммирования)

Наследование используется при создании структуры работы программы, обычно после прописания классов
обоснования использования:
- существенно сокращет код, путём создания иерархии классов, где каждый последущий слой наследует прошлый (animal.sound() -> cats -> home_cat.sound())

Инкапсуляция, используется после прописания структуры
обоснования использования:
- помогает защитить код из вне
- упрощает переиспользование кода ( robot.ride_left(){...} ->  obj_robot.ride_left())

Полиморфизм, используется уже после всего выше, во время прописания логики программы, имею ввиду уже конкретное прописание работы программы
обоснования использования:
- параметрический полиморфизм позволяет оперировать разными объектами, но с одинаковым интерфейсом (вывод метода sound у всех животных (home_cat, parrot, ape ...), если я помню правильно, то оно вроде как реализуется через контейнеры, для чего бы портебовалось гораздо больше кода) 
- ad-hoc полиморфизм помогает выьрать правильное наследование функции и свойств, и его переопределить (cat_barsik -> kitty <- cat_alice, kitty(){color = cat_barsik.color} )
- так-же ad-hoc добавляет возможность делать перегрузку операторов, что может упростить работу с разными объектами (bank_bill+ restaran_bill = расходы)
